<?php

namespace Etbusch\PostgresCtes;

use Illuminate\Database\Query\Builder as BaseBuilder;
use Etbusch\PostgresCtes\Grammars\CteGrammar as Grammar;

class CteBuilder extends BaseBuilder
{

    /**
     * Create a new query builder instance.
     *
     * @param  \Illuminate\Database\ConnectionInterface  $connection
     * @param  \Illuminate\Database\Query\Grammars\Grammar  $grammar
     * @param  \Illuminate\Database\Query\Processors\Processor  $processor
     * @return void
     */
    public function __construct(\Illuminate\Database\ConnectionInterface $connection,
                                Grammar $grammar = null,
                                \Illuminate\Database\Query\Processor $processor = null)
    {
        $this->connection = $connection;
        $this->grammar = $grammar ?: $connection->getQueryGrammar();
        $this->processor = $processor ?: $connection->getPostProcessor();
    }

    /**
     * The current query value bindings.
     *
     * @var array
     */
    public $bindings = [
        'with'   => [],
        'select' => [],
        'join'   => [],
        'where'  => [],
        'having' => [],
        'order'  => [],
        'union'  => [],
    ];


    /**
     * Add a subselect expression to the query.
     *
     * @param  \Closure|\Illuminate\Database\Query\Builder|string $query
     * @param  string  $as
     * @return \Illuminate\Database\Query\Builder|static
     *
     * @throws \InvalidArgumentException
     */
    public function cte($as, $query)
    {
        // If the given query is a Closure, we will execute it while passing in a new
        // query instance to the Closure. This will give the developer a chance to
        // format and work with the query before we cast it to a raw SQL string.
        if ($query instanceof Closure) {
            $callback = $query;

            $callback($query = $this->newQuery());
        }


        // Here, we will parse this query into an SQL string and an array of bindings
        // so we can add it to the query builder using the selectRaw method so the
        // query is included in the real SQL generated by this builder instance.
        list($query, $bindings) = $this->parseCteSelect($query);


        $this->with[] = $this->grammar->wrap($as).' as ('.$query.')';
       if ($bindings) {
            $this->addBinding($bindings, 'with');
        }
        return $this;
       /* return $this->selectRaw(
            $this->grammar->wrap($as).' as ('.$query.')', $bindings
        );*/
    }

    /**
     * Parse the sub-select query into SQL and bindings.
     *
     * @param  mixed  $query
     * @return array
     */
    protected function parseCteSelect($query)
    {
        if ($query instanceof self) {
           

            return [$query->toSql(), $query->getBindings()];
        } elseif (is_string($query)) {
            return [$query, []];
        } else {
            throw new InvalidArgumentException;
        }
    }    
}